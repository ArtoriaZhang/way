import{_ as e,c as t,o as s,a2 as a}from"./chunks/framework.Ii5gFk8W.js";const m=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/database/oracle/Tuning.md","filePath":"docs/database/oracle/Tuning.md"}'),o={name:"docs/database/oracle/Tuning.md"},r=a('<h2 id="in-versus-exists" tabindex="-1">In Versus Exists <a class="header-anchor" href="#in-versus-exists" aria-label="Permalink to &quot;In Versus Exists&quot;">â€‹</a></h2><p>Well, the two are processed very very differently.</p><p>Select * from T1 where x in ( select y from T2 )</p><p>is typically processed as:</p><p>select * from t1, ( select distinct y from t2 ) t2 where t1.x = t2.y;</p><p>The subquery is evaluated, distinct&#39;ed, indexed (or hashed or sorted) and then joined to the original table -- typically.</p><p>As opposed to</p><p>select * from t1 where exists ( select null from t2 where y = x )</p><p>That is processed more like:</p><p>for x in ( select * from t1 ) loop if ( exists ( select null from t2 where y = x.x ) then OUTPUT THE RECORD end if end loop</p><p>It always results in a full scan of T1 whereas the first query can make use of an index on T1(x).</p><p>So, when is where exists appropriate and in appropriate?</p><p>Lets say the result of the subquery ( select y from T2 )</p><p>is &quot;huge&quot; and takes a long time. But the table T1 is relatively small and executing ( select null from t2 where y = x.x ) is very very fast (nice index on t2(y)). Then the exists will be faster as the time to full scan T1 and do the index probe into T2 could be less then the time to simply full scan T2 to build the subquery we need to distinct on.</p><p>Lets say the result of the subquery is small -- then IN is typicaly more appropriate.</p><p>If both the subquery and the outer table are huge -- either might work as well as the other -- depends on the indexes and other factors.</p>',16),i=[r];function n(l,p,d,c,h,u){return s(),t("div",null,i)}const y=e(o,[["render",n]]);export{m as __pageData,y as default};
