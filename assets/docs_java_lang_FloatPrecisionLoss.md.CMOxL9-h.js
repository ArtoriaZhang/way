import{_ as s,E as n,c as i,m as t,J as d,w as r,a2 as e,o,a as l}from"./chunks/framework.CCoplHXX.js";const x=JSON.parse('{"title":"","description":"","frontmatter":{},"headers":[],"relativePath":"docs/java/lang/FloatPrecisionLoss.md","filePath":"docs/java/lang/FloatPrecisionLoss.md"}'),p={name:"docs/java/lang/FloatPrecisionLoss.md"},u=e('<p><a href="https://floating-point-gui.de/" target="_blank" rel="noreferrer">Origin From</a></p><h2 id="why-don-t-my-numbers-add-up" tabindex="-1">Why don&#39;t my numbers add up? <a class="header-anchor" href="#why-don-t-my-numbers-add-up" aria-label="Permalink to &quot;Why don&#39;t my numbers add up?&quot;">​</a></h2><p>So you’ve written some absurdly simple code, say for example:</p><p>🖊️ 0.1 + 0.2</p><p>and got a really unexpected result:</p><p>⚠️ 0.30000000000000004</p><p>Maybe you asked for help on some forum and got pointed to a long article with lots of formulas that didn’t seem to help with your problem.</p><p>Well, this site is here to:</p><ul><li>Explain concisely why you get that unexpected result</li><li>Tell you how to deal with this problem</li><li>If you’re interested, provide in-depth explanations of why floating-point numbers have to work like that and what other problems can arise</li></ul><p>You should look at the Basic Answers first - but don’t stop there!</p><h2 id="basic-answers" tabindex="-1">Basic Answers <a class="header-anchor" href="#basic-answers" aria-label="Permalink to &quot;Basic Answers&quot;">​</a></h2><h3 id="weird-result" tabindex="-1">Weird result <a class="header-anchor" href="#weird-result" aria-label="Permalink to &quot;Weird result&quot;">​</a></h3><p>Why don’t my numbers, like 0.1 + 0.2 add up to a nice round 0.3, and instead I get a weird result like 0.30000000000000004? Because internally, computers use a format <a href="#floating-point-numbers">(binary floating-point)</a> that cannot accurately represent a number like 0.1, 0.2 or 0.3 at all.</p><p>When the code is compiled or interpreted, your “0.1” is already rounded to the nearest number in that format, which results in a small rounding error even before the calculation happens.</p><h3 id="why-do-computers-use-such-a-stupid-system" tabindex="-1">Why do computers use such a stupid system? <a class="header-anchor" href="#why-do-computers-use-such-a-stupid-system" aria-label="Permalink to &quot;Why do computers use such a stupid system?&quot;">​</a></h3><p>It’s not stupid, just different. Decimal numbers cannot accurately represent a number like 1/3, so you have to round to something like 0.33 - and you don’t expect 0.33 + 0.33 + 0.33 to add up to 1, either - do you?</p><p>Computers use binary numbers because they’re faster at dealing with those, and because for most calculations, a tiny error in the 17th decimal place doesn’t matter at all since the numbers you work with aren’t round (or that precise) anyway.</p><h2 id="binary-fractions" tabindex="-1">Binary Fractions <a class="header-anchor" href="#binary-fractions" aria-label="Permalink to &quot;Binary Fractions&quot;">​</a></h2><h3 id="how-they-work" tabindex="-1">How they work <a class="header-anchor" href="#how-they-work" aria-label="Permalink to &quot;How they work&quot;">​</a></h3><p>As a programmer, you should be familiar with the concept of binary integers, i.e. the representation of integer numbers as a series of bits:</p><table><tbody><tr><th colspan="9">Decimal (<span class="num_base">base 10</span>)</th><th></th><th colspan="17">Binary (<span class="num_base">base 2</span>)</th></tr><tr class="base_example"><td class="digit">1</td><td>⋅</td><td class="num_base">10<sup>1</sup></td><td>+</td><td class="digit">3</td><td>⋅</td><td class="num_base">10<sup>0</sup></td><td>=</td><td class="digit">13<sub class="num_base">10</sub></td><td class="separator">=</td><td class="digit">1101<sub class="num_base">2</sub></td><td>=</td><td class="digit">1</td><td>⋅</td><td class="num_base">2<sup>3</sup></td><td>+</td><td class="digit">1</td><td>⋅</td><td class="num_base">2<sup>2</sup></td><td>+</td><td class="digit">0</td><td>⋅</td><td class="num_base">2<sup>1</sup></td><td>+</td><td class="digit">1</td><td>⋅</td><td class="num_base">2<sup>0</sup></td></tr><tr class="base_example"><td class="digit">1</td><td>⋅</td><td>10</td><td>+</td><td class="digit">3</td><td>⋅</td><td>1 </td><td>=</td><td class="digit">13<sub class="num_base">10</sub></td><td class="separator">=</td><td class="digit">1101<sub class="num_base">2</sub></td><td>=</td><td class="digit">1</td><td>⋅</td><td>8</td><td>+</td><td class="digit">1</td><td>⋅</td><td>4</td><td>+</td><td class="digit">0</td><td>⋅</td><td>2</td><td>+</td><td class="digit">1</td><td>⋅</td><td>1</td></tr></tbody></table><p>This is how computers store integer numbers internally. And for fractional numbers in positional notation, they do the same thing:</p><table><tbody><tr><th colspan="13">Decimal (<span class="num_base">base 10</span>)</th><th></th><th colspan="13">Binary (<span class="num_base">base 2</span>)</th></tr><tr class="base_example"><td class="digit">6</td><td>⋅</td><td class="num_base">10<sup>-1</sup></td><td>+</td><td class="digit">2</td><td>⋅</td><td class="num_base">10<sup>-2</sup></td><td>+</td><td class="digit">5</td><td>⋅</td><td class="num_base">10<sup>-3</sup></td><td>=</td><td class="digit">0.625<sub class="num_base">10</sub></td><td class="separator">=</td><td class="digit">0.101<sub class="num_base">2</sub></td><td>=</td><td class="digit">1</td><td>⋅</td><td class="num_base">2<sup>-1</sup></td><td>+</td><td class="digit">0</td><td>⋅</td><td class="num_base">2<sup>-2</sup></td><td>+</td><td class="digit">1</td><td>⋅</td><td class="num_base">2<sup>-3</sup></td></tr><tr class="base_example"><td class="digit">6</td><td>⋅</td><td>1/10</td><td>+</td><td class="digit">2</td><td>⋅</td><td>1/100</td><td>+</td><td class="digit">5</td><td>⋅</td><td>1/1000</td><td>=</td><td class="digit">0.625<sub class="num_base">10</sub></td><td class="separator">=</td><td class="digit">0.101<sub class="num_base">2</sub></td><td>=</td><td class="digit">1</td><td>⋅</td><td>1/2</td><td>+</td><td class="digit">0</td><td>⋅</td><td>1/4</td><td>+</td><td class="digit">1</td><td>⋅</td><td>1/8</td></tr></tbody></table><h3 id="problems" tabindex="-1">Problems <a class="header-anchor" href="#problems" aria-label="Permalink to &quot;Problems&quot;">​</a></h3><p>While they work the same in principle, binary fractions are different from decimal fractions in what numbers they can accurately represent with a given number of digits, and thus also in what numbers result in rounding errors:</p><p>Specifically, binary can only represent those numbers as a finite fraction where the denominator is a power of 2. Unfortunately, this does not include most of the numbers that can be represented as finite fraction in base 10, like 0.1.</p><h2 id="floating-point-numbers" tabindex="-1">Floating Point Numbers <a class="header-anchor" href="#floating-point-numbers" aria-label="Permalink to &quot;Floating Point Numbers&quot;">​</a></h2><h3 id="why-floating-point-numbers-are-needed" tabindex="-1">Why floating-point numbers are needed <a class="header-anchor" href="#why-floating-point-numbers-are-needed" aria-label="Permalink to &quot;Why floating-point numbers are needed&quot;">​</a></h3><p>Since computer memory is limited, you cannot store numbers with infinite precision, no matter whether you use binary fractions or decimal ones: at some point you have to cut off. But how much accuracy is needed? And where is it needed? How many integer digits and how many fraction digits?</p><ul><li>To an engineer building a highway, it does not matter whether it’s 10 meters or 10.0001 meters wide - their measurements are probably not that accurate in the first place.</li><li>To someone designing a microchip, 0.0001 meters (a tenth of a millimeter) is a huge difference - But they’ll never have to deal with a distance larger than 0.1 meters. A physicist needs to use the speed of light (about 300000000) and Newton’s gravitational constant (about 0.0000000000667) together in the same calculation.</li><li>To satisfy the engineer and the chip designer, a number format has to provide accuracy for numbers at very different magnitudes. However, only relative accuracy is needed. To satisfy the physicist, it must be possible to do calculations that involve numbers with different magnitudes.</li></ul><p>Basically, having a fixed number of integer and fractional digits is not useful - and the solution is a format with a floating point.</p><h3 id="how-floating-point-numbers-work" tabindex="-1">How floating-point numbers work <a class="header-anchor" href="#how-floating-point-numbers-work" aria-label="Permalink to &quot;How floating-point numbers work&quot;">​</a></h3><p>The idea is to compose a number of two main parts:</p><ul><li>A significand that contains the number’s digits. Negative significands represent negative numbers.</li><li>An exponent that says where the decimal (or binary) point is placed relative to the beginning of the significand. Negative exponents represent numbers that are very small (i.e. close to zero).</li></ul><p>Such a format satisfies all the requirements:</p><ul><li>It can represent numbers at wildly different magnitudes (limited by the length of the exponent)</li><li>It provides the same relative accuracy at all magnitudes (limited by the length of the significand)</li><li>It allows calculations across magnitudes: multiplying a very large and a very small number preserves the accuracy of both in the result. Decimal floating-point numbers usually take the form of <a href="https://en.wikipedia.org/wiki/Scientific_notation" target="_blank" rel="noreferrer"><strong>scientific notation</strong></a> <a href="#scientific-notation">current</a> with an explicit point always between the 1st and 2nd digits. The exponent is either written explicitly including the base, or an e is used to separate it from the significand.</li></ul><table><thead><tr><th>Significand</th><th>Exponent</th><th>Scientific notation</th><th>Fixed-point value</th></tr></thead><tbody><tr><td>1.5</td><td>4</td><td>1.5 ⋅ 10<sup>4</sup></td><td>15000</td></tr><tr><td>-2.001</td><td>2</td><td>-2.001 ⋅ 10<sup>2</sup></td><td>-200.1</td></tr><tr><td>5</td><td>-3</td><td>5 ⋅ 10<sup>-3</sup></td><td>0.005</td></tr><tr><td>6.667</td><td>-11</td><td>6.667e-11</td><td>0.00000000006667</td></tr></tbody></table><h3 id="the-standard" tabindex="-1">The standard <a class="header-anchor" href="#the-standard" aria-label="Permalink to &quot;The standard&quot;">​</a></h3><p>Nearly all hardware and programming languages use floating-point numbers in the same binary formats, which are defined in the IEEE 754 standard. The usual formats are 32 or 64 bits in total length:</p><table><thead><tr><th>Format</th><th>Total bits</th><th>Significand bits</th><th>Exponent bits</th><th>Smallest number</th><th>Largest number</th></tr></thead><tbody><tr><td>Single precision</td><td>32</td><td>23 + 1 sign</td><td>8</td><td>ca. 1.2 ⋅ 10<sup>-38</sup></td><td>ca. 3.4 ⋅ 10<sup>38</sup></td></tr><tr><td>Double precision</td><td>64</td><td>52 + 1 sign</td><td>11</td><td>ca. 2.2 ⋅ 10<sup>-308</sup></td><td>ca. 1.8 ⋅ 10<sup>308</sup></td></tr></tbody></table><p>Note that there are some peculiarities:</p><ul><li>The <strong>actual bit sequence</strong> is the sign bit first, followed by the exponent and finally the significand bits.</li><li>The exponent does not have a sign; instead an exponent bias is subtracted from it (127 for single and 1023 for double precision). This, and the bit sequence, allows floating-point numbers to be compared and sorted correctly even when interpreting them as integers.</li><li>The significand’s most significant digit is omitted and assumed to be 1, except for subnormal numbers which are marked by an all-0 exponent and allow a number range beyond the smallest numbers given in the table above, at the cost of precision.</li><li>There are separate positive and a negative zero values, differing in the sign bit, where all other bits are 0. These must be considered equal even though their bit patterns are different.</li><li>There are special positive and negative infinity values, where the exponent is all 1-bits and the significand is all 0-bits. These are the results of calculations where the positive range of the exponent is exceeded, or division of a regular number by zero.</li><li>There are special not a number (or NaN) values where the exponent is all 1-bits and the significand is not all 0-bits. These represent the result of various undefined calculations (like multiplying 0 and infinity, any calculation involving a NaN value, or application-specific cases). Even bit-identical NaN values must not be considered equal.</li></ul><p>If this seems too abstract and you want to see how some specific values look like in IEE 754, try the <a href="http://evanw.github.io/float-toy/" target="_blank" rel="noreferrer"><strong>Float Toy</strong></a>, or the <a href="https://bartaz.github.io/ieee754-visualization/" target="_blank" rel="noreferrer">IEEE 754 Visualization</a>, or <a href="https://float.exposed/0x40490fdb" target="_blank" rel="noreferrer">Float Exposed</a>.</p><h2 id="scientific-notation" tabindex="-1">Scientific Notation <a class="header-anchor" href="#scientific-notation" aria-label="Permalink to &quot;Scientific Notation&quot;">​</a></h2><p><strong>Scientific notation</strong> is a way of expressing numbers that are too large or too small to be conveniently written in decimal form, since to do so would require writing out an inconveniently long string of digits. It may be referred to as scientific form or standard index form, or standard form in the United Kingdom. This base ten notation is commonly used by scientists, mathematicians, and engineers, in part because it can simplify certain arithmetic operations. On scientific calculators, it is usually known as &quot;SCI&quot; display mode.</p><p>In scientific notation, nonzero numbers are written in the form</p>',46),c=t("sup",null,"n",-1),h=e('<table><thead><tr><th>Deciaml Notation</th><th>Scientific Notation</th></tr></thead><tbody><tr><td>2</td><td>2 x 10<sup>0</sup></td></tr><tr><td>300</td><td>3×10<sup>2</sup></td></tr><tr><td>4321.768</td><td>4.321768×10<sup>3</sup></td></tr><tr><td>−53000</td><td>−5.3×10<sup>4</sup></td></tr><tr><td>6720000000</td><td>6.72×10<sup>9</sup></td></tr><tr><td>0.2</td><td>2×10<sup>−1</sup></td></tr><tr><td>987</td><td>9.87×10<sup>2</sup></td></tr><tr><td>0.00000000751</td><td>7.51×10<sup>−9</sup></td></tr></tbody></table><table class="wikitable" style=""><tbody><tr><th>Decimal notation </th><th>Scientific notation </th></tr><tr><td><span class="nowrap">2</span></td><td><span class="nowrap">2<span style="margin-left:0.25em;margin-right:0.15em;">×</span>10<sup>0</sup></span></td></tr><tr><td><span class="nowrap">300</span></td><td><span class="nowrap">3<span style="margin-left:0.25em;margin-right:0.15em;">×</span>10<sup>2</sup></span></td></tr><tr><td><span class="nowrap">4<span style="margin-left:.25em;">321</span>.768</span></td><td><span class="nowrap">4.321<span style="margin-left:.25em;">768</span><span style="margin-left:0.25em;margin-right:0.15em;">×</span>10<sup>3</sup></span></td></tr><tr><td><span class="nowrap">−53<span style="margin-left:.25em;">000</span></span></td><td><span class="nowrap">−5.3<span style="margin-left:0.25em;margin-right:0.15em;">×</span>10<sup>4</sup></span></td></tr><tr><td><span class="nowrap">6<span style="margin-left:.25em;">720</span><span style="margin-left:.25em;">000</span><span style="margin-left:.25em;">000</span></span></td><td><span class="nowrap">6.72<span style="margin-left:0.25em;margin-right:0.15em;">×</span>10<sup>9</sup></span></td></tr><tr><td><span class="nowrap">0.2</span></td><td><span class="nowrap">2<span style="margin-left:0.25em;margin-right:0.15em;">×</span>10<sup>−1</sup></span></td></tr><tr><td><span class="nowrap">987</span></td><td><span class="nowrap">9.87<span style="margin-left:0.25em;margin-right:0.15em;">×</span>10<sup>2</sup></span></td></tr><tr><td><span class="nowrap">0.000<span style="margin-left:.25em;">000</span><span style="margin-left:.25em;">007</span><span style="margin-left:.25em;">51</span></span></td><td><span class="nowrap">7.51<span style="margin-left:0.25em;margin-right:0.15em;">×</span>10<sup>−9</sup></span></td></tr></tbody></table>',2);function m(b,g,f,y,w,_){const a=n("center");return o(),i("div",null,[u,t("p",null,[t("code",null,[d(a,null,{default:r(()=>[l(" m × 10"),c]),_:1})])]),h])}const k=s(p,[["render",m]]);export{x as __pageData,k as default};
