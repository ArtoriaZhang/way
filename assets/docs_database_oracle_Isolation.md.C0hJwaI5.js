import{_ as e,c as t,o as a,a2 as o}from"./chunks/framework.DyMc37k2.js";const b=JSON.parse('{"title":"Origin From","description":"","frontmatter":{},"headers":[],"relativePath":"docs/database/oracle/Isolation.md","filePath":"docs/database/oracle/Isolation.md"}'),i={name:"docs/database/oracle/Isolation.md"},s=o('<h1 id="origin-from" tabindex="-1">Origin <a href="https://asktom.oracle.com/Misc/oramag/on-transaction-isolation-levels.html" target="_blank" rel="noreferrer">From</a> <a class="header-anchor" href="#origin-from" aria-label="Permalink to &quot;Origin [From](https://asktom.oracle.com/Misc/oramag/on-transaction-isolation-levels.html)&quot;">​</a></h1><h2 id="isolationi-level" tabindex="-1">Isolationi level <a class="header-anchor" href="#isolationi-level" aria-label="Permalink to &quot;Isolationi level&quot;">​</a></h2><ol><li>Read Uncommited</li><li>Read Committed</li><li>Repeatable Read</li><li>Serializable</li></ol><ul><li><p><strong>Dirty read:</strong> The meaning of this term is as bad as it sounds. You&#39;re permitted to read uncommitted, or dirty , data. You can achieve this effect by just opening an OS file that someone else is writing and reading whatever data happens to be there. Data integrity is compromised, foreign keys are violated, and unique constraints are ignored.</p></li><li><p><strong>Nonrepeatable read:</strong> This simply means that if you read a row at time T1 and try to reread that row at time T2, the row may have changed. It may have disappeared, it may have been updated, and so on.</p></li><li><p><strong>Phantom read:</strong> This means that if you execute a query at time T1 and re-execute it at time T2, additional rows may have been added to the database, which may affect your results. This differs from a nonrepeatable read in that with a phantom read, data you already read hasn&#39;t been changed, but instead, more data satisfies your query criteria than before.</p></li></ul><p>Note that the ANSI/ISO SQL standard defines transaction-level characteristics, not just individual statement-by-statement-level characteristics. I&#39;ll examine transaction-level isolation, not just statement-level isolation.</p><p>The SQL isolation levels are defined based on whether they allow each of the preceding phenomena. It&#39;s interesting to note that the SQL standard doesn&#39;t impose a specific locking scheme or mandate particular behaviors, but rather describes these isolation levels in terms of these phenomena—allowing for many different locking/concurrency mechanisms to exist (see Table 1).</p><table><thead><tr><th>Isolation Level</th><th>Dirty Read</th><th>Nonrepeatable Read</th><th>Phantom Read</th></tr></thead><tbody><tr><td>READ UNCOMMITTED</td><td>Permitted</td><td>Permitted</td><td>Permitted</td></tr><tr><td>READ COMMITTED</td><td>--</td><td>Permitted</td><td>Permitted</td></tr><tr><td>REPEATABLE READ</td><td>--</td><td>--</td><td>Permitted</td></tr><tr><td>SERIALIZABLE</td><td></td><td>--</td><td>--</td></tr></tbody></table><p style="text-align:center;">***Table 1:*** ANSI isolation levels</p><ul><li><em><strong>READ UNCOMMITTED:</strong></em> The READ UNCOMMITTED isolation level allows dirty reads. Oracle Database doesn&#39;t use dirty reads, nor does it even allow them. The basic goal of a READ UNCOMMITTED isolation level is to provide a standards-based definition that allows for nonblocking reads. As you&#39;ve seen, Oracle Database provides for nonblocking reads by default. You&#39;d be hard-pressed to make a SELECT query block and wait in the database (as noted earlier, there is the special case of a distributed transaction). Every single query, be it a SELECT , INSERT , UPDATE , MERGE , or DELETE , executes in a read-consistent fashion. It might seem funny to refer to an UPDATE statement as a query, but it is. UPDATE statements have two components: a read component as defined by the WHERE clause, and a write component as defined by the SET clause. UPDATE statements read and write to the database, as do all DML statements. The case of a single row INSERT using the VALUES clause is the only exception to this, because such statements have no read component—just the write component.</li></ul>',9),n=[s];function r(d,l,h,c,m,u){return a(),t("div",null,n)}const f=e(i,[["render",r]]);export{b as __pageData,f as default};
